
# This script explains the steps for importing RNASeq data into R as well as filtering and normalizing it.

# ---- IMPORTING and FORMATTING THE DATA ----

# Installing packages----
# install.packages('tidyverse')
# install.packages("tximport")
# install.packages('ensembldb')

# Loading packages----
library(tidyverse) # provides access to Hadley Wickham's collection of R packages for data science
library(tximport) # package to import Kallisto results into R
library(ensembldb) #helps deal with ensembl
library(biomaRt) # retrieving annotations for tomato

targets <- read_tsv("study_design_assignment.txt") # import a study design file 

lyc.anno <- useMart(biomart="plants_mart", dataset = "slycopersicum_eg_gene", host="https://plants.ensembl.org") # access the ensembl annotations for tomato genomes

#Formatting - take a look at all available attributes within the selected tomato annotation
Tx.lyc <- getBM(attributes=c('ensembl_transcript_id',
                             'ensembl_gene_id', 'description'),
                mart = lyc.anno) %>%
  as_tibble() %>%  # turn it into a table 
  dplyr::rename(target_id = ensembl_transcript_id, gene_name = ensembl_gene_id)  %>% #we need to rename the two columns we just retrieved from biomart
  dplyr::select("target_id", "gene_name") # #transcript ID needs to be the first column in the dataframe

#Importing Kallisto transcript counts into R using Tximport 
path <- file.path(targets$sample, "abundance.tsv") # set file paths to (your mapped data) to the abundance files generated by Kallisto using the 'file.path' function
all(file.exists(path)) #check to make sure that this path is correct by seeing if the files exist,the all() function
# will return TRUE if every element in the logical vector is TRUE.
Txi_gene <- tximport(path, 
                     type = "kallisto", 
                     tx2gene = Tx.lyc, #Mapping from transcript IDs to gene IDs
                     txOut = T, #determines whether your data represented at transcript or gene level if false data represented at gene level instead of at transcript level 
                     countsFromAbundance = "lengthScaledTPM",
                     ignoreTxVersion = T)


# ---- FILTERING and NORMALIZATION ----

#Installing packages ----
# install.packages("edgeR")
# install.packages('matrixStats')
# install.packages('cowplot')

# Loading packages ----
library(tidyverse) 
library(edgeR) # package for differential expression analysis(here only used for the DGEList object and for normalization methods)
library(matrixStats) # allows us easily calculate stats on rows or columns of a data matrix
library(cowplot) # allows us to combine multiple plots in one figure

#Visualization of abundances
myTPM <- Txi_gene$abundance # abundances in transcripts per million 
myCounts <- Txi_gene$counts  # counts are read counts mapping to each gene or transcript
colSums(myTPM)
colSums(myCounts)

# Generate summary stats for the abundance data
myTPM.stats <- transform(myTPM, 
                         SD=rowSds(myTPM), 
                         AVG=rowMeans(myTPM),
                         MED=rowMedians(myTPM))

#To look at what we created 
head(myTPM.stats)

#Produce a scatter plot of the transformed data
ggplot(myTPM.stats) +   
  aes(x = SD, y = MED) +
  geom_point(shape=1, size=3) 

# Let's expand on the plot above and take a look at each 'layer' of the ggplot code
ggplot(myTPM.stats) + 
  aes(x = SD, y = MED) +
  geom_point(shape=1, size=2) +
  geom_smooth(method=lm) +
  geom_hex(show.legend = T, bins=20) +
  labs(y="Median", x = "Standard deviation",
       title="Transcripts per million (TPM)",
       subtitle="unfiltered, non-normalized data",
       caption="DIYtranscriptomics - Spring 2020") +
  # theme_classic() +
  # theme_dark() 
  theme_bw()        

#Visualization of counts 
# capture sample labels from the study design file and saved as 'targets' above
targets
sampleLabels <- targets$sample

myDGEList <- DGEList(myCounts) # make a DGElist from the counts 
# take a look at the DGEList object 
myDGEList

save(myDGEList, file = "myDGEList")
#Saved DGEList objects can be easily shared and loaded into an R environment
load(file = "myDGEList")

# use the 'cpm' function from EdgeR to get counts per million
cpm <- cpm(myDGEList) #convert to counts per million 
colSums(cpm)
log2.cpm <- cpm(myDGEList, log=TRUE)

log2.cpm.df <- as_tibble(log2.cpm, rownames = "geneID")
log2.cpm.df
# add the sample names to this dataframe
colnames(log2.cpm.df) <- c("geneID", sampleLabels)
# use the tidy package to 'pivot' the dataframe (from wide to long)
log2.cpm.df.pivot <- pivot_longer(log2.cpm.df, # dataframe to be pivoted
                                  cols = S01:C03, # column names to be stored as a SINGLE variable
                                  names_to = "samples", # name of that new variable (column)
                                  values_to = "expression") # name of new variable (column) storing all the values (data)

# let's look at the impact of pivoting the data
log2.cpm.df.pivot

p1 = ggplot(log2.cpm.df.pivot) +
  aes(x=samples, y=expression, fill=samples) +
  geom_violin(trim = FALSE, show.legend = FALSE) +
  stat_summary(fun = "median", 
               geom = "point", 
               shape = 95, 
               size = 10, 
               color = "black", 
               show.legend = FALSE) +
  labs(y="log2 expression", x = "sample",
       title="Log2 Counts per Million (CPM)",
       subtitle="unfiltered, non-normalized",
       caption=paste0("produced on ", Sys.time())) +
  theme_bw()

#Filtering the data  ----
table(rowSums(myDGEList$counts==0)==10) #genes not expressed in all samples 

keepers <- rowSums(cpm>1)>=5 #keep genes with a total count above 1 CPM over any 5 samples 
                            
# now use base R's simple subsetting method to filter the DGEList 
myDGEList.filtered <- myDGEList[keepers,]
dim(myDGEList.filtered)

log2.cpm.filtered <- cpm(myDGEList.filtered, log=TRUE) #convert to cpm and log2 scale 
log2.cpm.filtered.df <- as_tibble(log2.cpm.filtered, rownames = "geneID") #format 
colnames(log2.cpm.filtered.df) <- c("geneID", sampleLabels)
# pivot this FILTERED data
log2.cpm.filtered.df.pivot <- pivot_longer(log2.cpm.filtered.df, # dataframe to be pivoted
                                           cols = S01:C03, # column names to be stored as a SINGLE variable
                                           names_to = "samples", # name of that new variable (column)
                                           values_to = "expression") # name of new variable (column) storing all the values (data)


p2 = ggplot(log2.cpm.filtered.df.pivot) +
  aes(x=samples, y=expression, fill=samples) +
  geom_violin(trim = FALSE, show.legend = FALSE) +
  stat_summary(fun = "median", 
               geom = "point", 
               shape = 95, 
               size = 10, 
               color = "black", 
               show.legend = FALSE) +
  labs(y="log2 expression", x = "sample",
       title="Log2 Counts per Million (CPM)",
       subtitle="filtered, non-normalized",
       caption=paste0("produced on ", Sys.time())) +
  theme_bw()

# Normalization ----
myDGEList.filtered.norm <- calcNormFactors(myDGEList.filtered, method = "TMM") # calculate normalization factors

# use the 'cpm' function from EdgeR to get counts per million from the normalized data
log2.cpm.filtered.norm <- cpm(myDGEList.filtered.norm, log=TRUE) # convert to cpm and log2 scale 
log2.cpm.filtered.norm.df <- as_tibble(log2.cpm.filtered.norm, rownames = "geneID") #format 
colnames(log2.cpm.filtered.norm.df) <- c("geneID", sampleLabels)
# pivot this NORMALIZED data
log2.cpm.filtered.norm.df.pivot <- pivot_longer(log2.cpm.filtered.norm.df, # dataframe to be pivoted
                                                cols = S01:C03, # column names to be stored as a SINGLE variable
                                                names_to = "samples", # name of that new variable (column)
                                                values_to = "expression") # name of new variable (column) storing all the values (data)



p3 = ggplot(log2.cpm.filtered.norm.df.pivot) +
  aes(x=samples, y=expression, fill=samples) +
  geom_violin(trim = FALSE, show.legend = FALSE) +
  stat_summary(fun = "median", 
               geom = "point", 
               shape = 95, 
               size = 10, 
               color = "black", 
               show.legend = FALSE) +
  labs(y="log2 expression", x = "sample",
       title="Log2 Counts per Million (CPM)",
       subtitle="filtered, TMM normalized",
       caption=paste0("produced on ", Sys.time())) +
  theme_bw()


# we'll use the 'plot_grid' function from the cowplot package to put these together in a figure
plot_grid(p1, p2, p3, labels = c('A', 'B', 'C'), label_size = 12) # to plot all 3 violin plots in a figure 












